# 05. 산출물 해석 가이드

> 대상: **분석가, 기획자** 필독

---

## 산출물 전체 맵

```
output/
├── reports/                          ← 정량 데이터 + 보고서
│   ├── inventory.json                   인벤토리 (JSON)
│   ├── 01_inventory_report.md           인벤토리 보고서
│   ├── dependency-scan.json             의존성 분석 (JSON)
│   ├── priority_matrix.md               ★ 우선순위 매트릭스
│   ├── priority_data.json               우선순위 점수 (JSON)
│   ├── claude_priority_analysis.md      Claude 원본 분석
│   └── analysis_log.json               분석 실행 기록
│
├── docs/                             ← ★ 프로그램별 비즈니스 로직 분석서
│   ├── PGM001.md                       조업업무 - 일일 생산실적 집계
│   ├── PGM002.md                       출하업무 - 재고 트랜잭션 처리
│   ├── PGM003.md                       품질관리 - 품질검사 결과 처리
│   ├── PGM004.md                       생산관리 - 생산계획 대비 실적 분석
│   ├── PGM005.md                       조업업무 - 용광로 조업 데이터 처리
│   └── PGM006.md                       원자재관리 - 원자재 입출고 관리
│
├── data-dict/                        ← COPYBOOK 데이터 사전
│   ├── CPYTRANS.md                     생산실적 트랜잭션 레코드
│   ├── CPYSMRY.md                      일일 생산집계 요약
│   └── ... (총 13개)
│
└── diagrams/                         ← 시각화 다이어그램
    ├── call_graph.md                   호출관계 그래프
    ├── data_flow.md                    데이터 흐름도
    ├── jcl_flow.md                     JCL 배치 흐름도
    ├── erd_copybooks.md                ERD
    └── README.md                       다이어그램 목차
```

---

## 1. 비즈니스 로직 분석서 (output/docs/*.md)

**가장 중요한 산출물**. Claude AI가 COBOL 소스를 읽고 한국어로 해석한 문서입니다.

### 문서 구조

```
1. 프로그램 개요
   ├── 프로그램 ID, 목적, 처리 유형
   ├── 업무 카테고리
   ├── 복잡도 평가
   └── 주요 입출력

2. 데이터 흐름
   ├── 입력 데이터 (VSAM/DB2/파일)
   ├── 출력 데이터
   ├── 사용 COPYBOOK (역할, 주요 필드)
   └── 호출 관계 (호출/피호출)

3. 비즈니스 로직 상세
   └── SECTION/PARAGRAPH별 설명
       ├── 목적
       ├── 처리 흐름 (단계별)
       ├── 조건 분기 (비즈니스 의미)
       ├── 호출 서브프로그램
       └── 에러 처리

4. 비즈니스 규칙 요약
   └── 핵심 규칙 번호 목록 (88-level 조건명 포함)

5. MES 관련도 평가
   ├── MES 직접 관련 여부 (높음/중간/낮음/없음)
   ├── 관련 MES 기능
   └── 모더나이제이션 시 주의사항

6. 특이사항/리스크
   └── [HIGH/MEDIUM/LOW] 심각도 태그 포함
```

### 읽는 방법

**분석가**: 섹션 3(비즈니스 로직 상세)과 4(비즈니스 규칙)에 집중
- 기존 업무 흐름 이해
- 비즈니스 규칙 누락 없이 새 시스템에 반영되는지 검증

**기획자**: 섹션 1(개요)과 5(MES 관련도)에 집중
- 각 프로그램의 업무 범위 파악
- MES 전환 시 주의사항 확인

**설계자**: 섹션 2(데이터 흐름)과 6(리스크)에 집중
- 입출력 데이터 매핑
- 기술적 리스크 사전 파악

---

## 2. 우선순위 매트릭스 (output/reports/priority_matrix.md)

모더나이제이션 전환 순서를 결정하는 핵심 의사결정 문서입니다.

### 현재 결과 요약

| 순위 | 프로그램 | 최종점수 | 비즈니스 | 전환방식 | Phase |
|------|---------|---------|---------|---------|-------|
| 1 | PGM005 | 8.2 | 8 | 하이브리드 | Phase 1 |
| 2 | PGM003 | 8.0 | 9 | 하이브리드 | Phase 1 |
| 3 | PGM002 | 7.5 | 8 | 자동 변환 | Phase 1 |
| 4 | PGM004 | 7.3 | 7 | 자동 변환 | Phase 1 |
| 5 | PGM001 | 6.8 | 9 | 자동 변환 | Phase 2 |
| 6 | PGM006 | 6.8 | 7 | 자동 변환 | Phase 2 |

### 점수 지표 해석

| 지표 | 의미 | 높은 점수 (10) | 낮은 점수 (1) |
|------|------|-------------|-------------|
| **비즈니스 중요도** | MES 핵심 업무 여부 | 핵심 생산/품질 업무 | 보조/참조 업무 |
| **기술 복잡도** | 전환 난이도 | 분기 많고 복잡 | 단순 순차 처리 |
| **의존성 영향도** | 변경 시 파급 범위 | 많은 프로그램이 의존 | 독립적 |
| **전환 용이도** | 자동화 가능성 | 쉽게 변환 가능 | CICS/복잡도로 어려움 |

### 전환 방식 가이드

| 방식 | 의미 | 적용 조건 |
|------|------|----------|
| **자동 변환** | 도구 기반 코드 변환 | 단순 로직, CICS 미사용 |
| **하이브리드** | 자동 변환 + 수동 보정 | 중간 복잡도 |
| **리라이트** | 완전 새로 개발 | CICS 사용 또는 매우 복잡 |

### 활용 방법

**기획자**: Phase 분류를 기준으로 전환 로드맵 수립
- Phase 1 프로그램 → 즉시 착수
- Phase 2 프로그램 → 3개월 내 착수
- 전환 방식별로 리소스(인력, 도구) 계획

**분석가**: 비즈니스 중요도 점수 검증
- Claude가 부여한 점수가 실제 업무 중요도와 부합하는지 확인
- 필요 시 catm_config.yaml의 가중치 조정 후 재실행

---

## 3. 의존성 분석 데이터 (output/reports/dependency-scan.json)

프로그램 간 관계를 정량적으로 보여주는 핵심 데이터입니다.

### 주요 활용 포인트

#### 프로그램별 의존성 확인
```json
{
  "name": "PGM001",
  "calls": ["ABNDPGM", "ERRLOG", "SQLERR"],     ← 호출하는 서브프로그램
  "copies": ["CPYSMRY", "CPYTRANS"],              ← 참조하는 COPYBOOK
  "db2_tables": ["TB_DAILY_PROD"],                 ← 접근하는 DB2 테이블
  "vsam_files": ["DLYSMRY", "PRODTRAN"],           ← 접근하는 VSAM 파일
  "complexity": 12,                                ← McCabe 복잡도
  "category": "조업업무"                            ← 업무 카테고리
}
```

#### 교차 참조 활용
```json
"cross_reference": {
  "copybook_usage": {
    "CPYTRANS": ["PGM001"],     ← CPYTRANS를 사용하는 프로그램 목록
    "CPYQCRS": ["PGM003"]
  },
  "called_by": {
    "SQLERR": ["PGM001", "PGM002", "PGM003"],  ← SQLERR을 호출하는 프로그램
    "ERRLOG": ["PGM001", "PGM002", ...]
  }
}
```

**활용**: 특정 COPYBOOK이나 서브프로그램을 수정할 때 영향받는 프로그램 파악

#### 영향도 점수 활용
```json
"impact_scores": {
  "SQLERR": 1.0,       ← 모든 프로그램이 사용 (6/6)
  "ERRLOG": 1.0,       ← 모든 프로그램이 사용 (6/6)
  "CPYTRANS": 0.17     ← 1개 프로그램만 사용 (1/6)
}
```

**활용**: 영향도 높은 공통 모듈(SQLERR, ERRLOG)은 최우선 전환 대상

#### 데드 코드 확인
```json
"dead_code": {
  "orphan_programs": ["PGM001", ...],  ← JCL/CALL에서 참조되지 않는 프로그램
  "unused_copybooks": []
}
```

**주의**: 고아 프로그램이라고 반드시 미사용은 아닙니다. JCL이 제공되지 않은 경우 이 목록에 나올 수 있습니다.

---

## 4. 데이터 사전 (output/data-dict/*.md)

COPYBOOK의 필드 구조를 테이블 형태로 보여줍니다.

### 문서 구조

```
필드 정의 테이블:
| Lv | 필드명 | PIC | 데이터 타입 | OCCURS | REDEFINES | 기본값 |

요약:
  그룹 항목 수, 기본 항목 수, 배열 수, REDEFINES 수, 총 필드 수
```

### 읽는 방법

- **Lv 01~05**: 상위 구조 (그룹 레벨)
- **Lv 05 이상**: 실제 데이터 필드
- **PIC X**: 문자열, **PIC 9**: 숫자, **PIC S9V99**: 부호 소수점
- **COMP-3**: 패킹 십진수 (데이터 마이그레이션 시 변환 필요)
- **OCCURS**: 배열 (MES 설계 시 별도 테이블 분리 검토)
- **REDEFINES**: 동일 메모리 재정의 (데이터 해석 주의)

---

## 5. 다이어그램 (output/diagrams/*.md)

Mermaid 형식의 다이어그램입니다. GitHub, VS Code, Notion 등에서 렌더링됩니다.

### 호출관계 그래프 (call_graph.md)
```
누가 누구를 호출하는지 한눈에 파악

읽는 방법:
  실선 화살표(→) = CALL 관계
  점선 화살표(-..->) = COPY 관계
  양방향 화살표(<-->) = DB2 SQL 연결
  파란 노드 = 메인 프로그램
  녹색 노드 = 서브 프로그램
```

### 데이터 흐름도 (data_flow.md)
```
프로그램이 어떤 데이터를 읽고 쓰는지

읽는 방법:
  SQL 라벨 = DB2 테이블 접근
  I/O 라벨 = VSAM 파일 접근
  둥근 사각형 = DB2 테이블
  사다리꼴 = VSAM 파일
```

### ERD (erd_copybooks.md)
```
COPYBOOK 기반 데이터 모델

읽는 방법:
  각 엔티티 = COPYBOOK 하나
  필드 타입 = string(문자)/number(숫자)
```

---

## 6. 인벤토리 보고서 (output/reports/01_inventory_report.md)

소스코드 전체 규모를 보여주는 초기 보고서입니다.

### 주요 내용
- 카테고리별 파일 수, 라인 수, 크기
- COBOL 프로그램 통계 (평균/최대/최소 라인 수)
- 프로그램 목록 (라인 수 내림차순)
- COPYBOOK 목록

### 활용
- 프로젝트 규모 산정 기초 자료
- 대형 프로그램 식별 (우선 분석 대상)
- 소스코드 추출 누락 여부 확인

---

## 산출물 활용 시나리오

### 시나리오 1: 전환 로드맵 수립 (기획자)

```
1. priority_matrix.md 확인 → Phase별 프로그램 분류
2. 각 프로그램의 docs/*.md 확인 → 업무 범위 파악
3. 전환 방식별(자동변환/하이브리드/리라이트) 리소스 계획
4. dependency-scan.json의 교차참조 → 전환 순서 최적화
   (공통 모듈 먼저 전환 → 의존하는 프로그램 순서대로)
```

### 시나리오 2: 요구사항 정의 (분석가)

```
1. docs/*.md의 "비즈니스 규칙 요약" → 기능 요구사항 도출
2. data-dict/*.md → 데이터 요구사항 도출
3. diagrams/data_flow.md → 인터페이스 요구사항 도출
4. docs/*.md의 "MES 관련도" → 비기능 요구사항 도출
```

### 시나리오 3: 신규 시스템 설계 (설계자)

```
1. diagrams/call_graph.md → 서비스/모듈 경계 설계
2. diagrams/erd_copybooks.md → 데이터 모델 설계
3. dependency-scan.json의 impact_scores → 공통 모듈 식별
4. docs/*.md의 "리스크" → 설계 시 고려사항 반영
```

### 시나리오 4: 특정 프로그램 변경 영향도 분석

```
1. dependency-scan.json에서 해당 프로그램의 의존성 확인
2. cross_reference로 역방향 참조 확인
3. impact_scores로 파급 범위 정량 파악
4. 영향받는 프로그램의 docs/*.md로 비즈니스 영향 평가
```
