# PGM001 - 비즈니스 로직 분석서

> 자동 생성 by CATM (Claude Code Max 20x)

## 1. 프로그램 개요

| 항목 | 내용 |
|------|------|
| 프로그램 ID | PGM001 |
| 프로그램 목적 | 전일 생산라인별 실적을 집계하여 일일 생산보고서를 생성하고, DB2 테이블에 집계 결과를 반영하는 배치 프로그램 |
| 처리 유형 | 배치 |
| 주요 입력 | PROD-TRANS-FILE (생산실적 트랜잭션 VSAM 인덱스 파일) |
| 주요 출력 | DAILY-SUMMARY-FILE (일일 집계 순차 파일), TB_DAILY_PROD (DB2 테이블 갱신) |

## 2. 데이터 흐름

### 입력 데이터
- **PROD-TRANS-FILE** (DD: PRODTRAN) — VSAM 인덱스 파일, 순차 접근 모드로 전체 레코드를 순회. 레코드 구조는 CPYTRANS COPYBOOK 참조

### 출력 데이터
- **DAILY-SUMMARY-FILE** (DD: DLYSMRY) — 순차 파일, 일일 집계 결과 1건 기록 (총 생산수량, 처리 건수, 에러 건수)
- **TB_DAILY_PROD** (DB2 테이블) — 당일 날짜 기준으로 집계 수량/건수/에러 건수를 UPDATE

### 사용 COPYBOOK
- **CPYTRANS** — 생산실적 트랜잭션 레코드 구조 (공장코드, 라인코드, 생산일자, 제품코드, 수량, 근무조 등)
- **CPYSMRY** — 일일 집계 요약 레코드 구조 (소스 미제공, DS-TOTAL-QTY / DS-TOTAL-COUNT / DS-ERROR-COUNT 필드 사용)
- **DCLTBPROD** (DCLGEN) — TB_DAILY_PROD 테이블의 호스트 변수 선언

## 3. 비즈니스 로직 상세

### 0000-MAIN-PROCESS (메인 제어)
- **목적**: 프로그램 전체 처리 흐름을 제어하는 최상위 단락
- **처리 흐름**:
  1. 초기화 수행 (파일 오픈, 첫 레코드 읽기)
  2. EOF까지 생산실적 레코드를 반복 처리
  3. 집계 결과를 요약 파일에 기록
  4. DB2 테이블에 집계 결과 반영
  5. 종료 처리 (파일 닫기, 완료 메시지 출력)

### 1000-INITIALIZE (초기화)
- **목적**: 입출력 파일을 열고 정상 오픈 여부를 확인
- **처리 흐름**:
  1. 생산실적 트랜잭션 파일을 INPUT으로 OPEN
  2. 일일 집계 파일을 OUTPUT으로 OPEN
  3. FILE STATUS가 '00'이 아니면 비정상 종료 수행
  4. 첫 번째 레코드를 선행 읽기 (priming read)
- **에러 처리**: 파일 OPEN 실패 시 9900-ABNORMAL-END로 분기하여 프로그램 강제 종료

### 1100-READ-FIRST-RECORD (첫 레코드 읽기)
- **목적**: 루프 진입 전 첫 번째 레코드를 미리 읽는 선행 읽기(priming read) 패턴
- **처리 흐름**: 레코드를 1건 읽고, 파일 끝이면 EOF 플래그를 설정

### 2000-PROCESS-RECORDS (실적 레코드 처리)
- **목적**: 개별 생산실적 트랜잭션을 검증하고 집계에 반영
- **처리 흐름**:
  1. 생산수량(PT-QTY)을 기준으로 3가지 경우를 분기 처리
  2. 처리 후 다음 레코드를 읽기 (trailing read)
- **조건 분기** (EVALUATE):
  - **PT-QTY > 0** (정상 생산): 생산수량을 라인 합계에 가산, 처리 건수를 1 증가
  - **PT-QTY = 0** (수량 없음): 에러 건수만 1 증가 (로그 기록 없이 스킵)
  - **기타 (음수 등)**: ERRLOG 서브프로그램을 호출하여 에러 로그를 기록하고, 에러 건수를 1 증가
- **호출 서브프로그램**: `ERRLOG` — 라인코드(PT-LINE-CD)와 수량(PT-QTY)을 전달하여 이상 데이터를 기록

### 3000-WRITE-SUMMARY (집계 결과 기록)
- **목적**: 누적된 집계 값을 일일 요약 파일에 1건 출력
- **처리 흐름**:
  1. 총 생산수량(WS-LINE-TOTAL)을 DS-TOTAL-QTY에 이동
  2. 총 처리건수(WS-DAILY-COUNT)를 DS-TOTAL-COUNT에 이동
  3. 총 에러건수(WS-ERROR-COUNT)를 DS-ERROR-COUNT에 이동
  4. DAILY-SUMMARY-REC를 WRITE

### 4000-UPDATE-DB2 (DB2 테이블 갱신)
- **목적**: 집계 결과를 DB2 일일생산 테이블에 반영
- **처리 흐름**:
  1. TB_DAILY_PROD 테이블에서 당일 날짜(CURRENT DATE) 행을 찾아 총수량/총건수/에러건수를 UPDATE
  2. SQLCODE가 0이 아니면 SQLERR 서브프로그램 호출
- **호출 서브프로그램**: `SQLERR` — SQLCODE를 전달하여 SQL 에러를 기록
- **에러 처리**: SQL 에러 발생 시 SQLERR을 호출하지만 프로그램을 중단하지는 않음 (처리 계속 진행)

### 9000-FINALIZE (종료 처리)
- **목적**: 파일을 닫고 처리 완료 메시지를 출력
- **처리 흐름**:
  1. 입력/출력 파일 CLOSE
  2. 처리 건수를 포함한 완료 메시지를 DISPLAY

### 9900-ABNORMAL-END (비정상 종료)
- **목적**: 파일 오류 등 치명적 에러 발생 시 프로그램을 강제 종료
- **처리 흐름**:
  1. 에러 메시지와 FILE STATUS 값을 DISPLAY
  2. ABNDPGM 서브프로그램을 호출하여 비정상 종료 처리
  3. STOP RUN으로 프로그램 즉시 종료
- **호출 서브프로그램**: `ABNDPGM` — FILE STATUS를 전달하여 운영팀에 ABEND를 통보

## 4. 비즈니스 규칙 요약

1. **생산수량 양수(> 0)**: 정상 실적으로 간주하여 라인별 합계에 누적하고 처리 건수를 증가시킨다
2. **생산수량 제로(= 0)**: 비정상 데이터로 간주하여 집계에서 제외하고 에러 건수만 증가시킨다 (별도 로그 없음)
3. **생산수량 음수(< 0)**: 심각한 이상 데이터로 간주하여 ERRLOG를 통해 상세 로그를 기록하고 에러 건수를 증가시킨다
4. **일일 집계는 전체 라인을 통합**: 라인코드별 소계 없이 전체 공장의 총합만 산출한다
5. **DB2 갱신은 당일 기준**: CURRENT DATE를 조건으로 UPDATE하며, 해당 행이 없으면 0건 갱신 (INSERT 없음)
6. **DB2 에러 시 계속 진행**: SQL 에러가 발생해도 프로그램이 중단되지 않고 종료 처리까지 수행한다

## 5. MES 관련도 평가

| 항목 | 평가 |
|------|------|
| MES 직접 관련 여부 | **높음** |
| 관련 MES 기능 | **생산관리** (생산실적 집계), **품질관리** (불량/재작업 상태코드 존재), **실적보고** (일일 생산보고서 생성) |
| 모더나이제이션 시 주의사항 | (1) 실시간 집계로 전환 시 배치 → 이벤트 기반 아키텍처 변경 필요 (2) ERRLOG/SQLERR/ABNDPGM 서브프로그램의 현대화 대상 식별 필요 (3) DB2 UPDATE 조건이 CURRENT DATE이므로 배치 실행 시점과 업무일자 불일치 가능성 검토 필요 (4) CPYSMRY COPYBOOK 구조 확인 후 API 응답 스키마 설계 필요 |

## 6. 특이사항/리스크

- **라인별 소계 미산출**: WS-CURRENT-LINE 변수가 선언되어 있으나 어디서도 사용되지 않음. 원래 라인별 집계 기능이 설계되었으나 구현되지 않았거나 제거된 것으로 추정 → **데드코드** (WS-CURRENT-LINE)
- **FILE STATUS 단일 변수 공유 위험**: WS-FILE-STATUS는 PROD-TRANS-FILE에만 연결되어 있고 WS-FILE-STATUS2는 DAILY-SUMMARY-FILE에 연결되어 있으나, 1000-INITIALIZE에서 OPEN 에러 체크가 WS-FILE-STATUS만 확인함. DAILY-SUMMARY-FILE의 OPEN 실패를 감지하지 못할 수 있음
- **DB2 UPDATE 0건 갱신 무시**: TB_DAILY_PROD에 당일 행이 없으면 SQLCODE=0이 반환되어(0건 UPDATE는 정상) 실제로는 데이터가 반영되지 않았음에도 정상 종료됨. INSERT 또는 MERGE 로직이 없어 데이터 누락 위험
- **COMP-3 수량 필드**: PT-QTY가 S9(9)V99 COMP-3(패킹 십진수)으로 부호를 포함하므로 음수값이 입력될 수 있으며, 이를 EVALUATE에서 처리하고 있음
- **근무조/상태코드 미활용**: CPYTRANS에 근무조(PT-SHIFT-CD)와 상태코드(PT-STATUS-CD, 정상/불량/재작업) 88-레벨 조건이 정의되어 있으나 프로그램에서 전혀 활용하지 않음. 정상/불량/재작업 구분 없이 수량만으로 판단하고 있어, 품질 관련 분석이 누락되어 있음
- **WRITE 에러 미처리**: 3000-WRITE-SUMMARY에서 WRITE 후 FILE STATUS 확인을 하지 않음
- **CLOSE 에러 미처리**: 9000-FINALIZE에서 CLOSE 후 FILE STATUS 확인을 하지 않음